# 多线程

## 1 leetcode题目

### 1.1 [1114.按序打印](https://leetcode-cn.com/problems/print-in-order/)

自旋锁：当一个线程在获取锁的时候，如果锁已经被其它线程获取，那么该线程将循环等待，然后不断的判断锁是否能够被成功获取，直到获取到锁才会退出循环。

```java
class Foo {
    AtomicInteger integerSecond = new AtomicInteger(0);
    AtomicInteger integerThird = new AtomicInteger(0);

    public Foo() {

    }

    public void first(Runnable printFirst) throws InterruptedException {

        // printFirst.run() outputs "first". Do not change or remove this line.
        printFirst.run();
        integerSecond.incrementAndGet();
    }

    public void second(Runnable printSecond) throws InterruptedException {
        // intergerSecond未更新则一直等待
        while(integerSecond.get()!=1){

        }
        // printSecond.run() outputs "second". Do not change or remove this line.
        printSecond.run();
        integerThird.incrementAndGet();
    }

    public void third(Runnable printThird) throws InterruptedException {
        // intergerThird未更新则一直等待
        while(integerThird.get()!=1){
            
        }
        // printThird.run() outputs "third". Do not change or remove this line.
        printThird.run();
    }
}
```

这里的while即一个自旋锁，等待原子信号量`integerSecond`或`integerThird`为1才会继续往下执行

### 1.2 [1115. 交替打印FooBar](https://leetcode-cn.com/problems/print-foobar-alternately/)

令牌桶：信号量`foo`和`bar`是两个令牌桶，`foo`里面初始就有令牌1个（同一个时刻可以运行一个线程），`bar`里面初始无令牌，`bar.acquire()`无法执行，需要等待`bar.release()`才能继续执行

* acquire拿到令牌才能往下走
* release往桶里面放令牌

```java
class FooBar {
    private Semaphore foo = new Semaphore(1);
    private Semaphore bar = new Semaphore(0);

    private int n;

    public FooBar(int n) {
        this.n = n;
    }

    public void foo(Runnable printFoo) throws InterruptedException {

        for (int i = 0; i < n; i++) {
            foo.acquire();
            // printFoo.run() outputs "foo". Do not change or remove this line.
            printFoo.run();
            bar.release();
        }
    }

    public void bar(Runnable printBar) throws InterruptedException {

        for (int i = 0; i < n; i++) {
            bar.acquire();
            // printBar.run() outputs "bar". Do not change or remove this line.
            printBar.run();
            foo.release();
        }
    }
}
```

## 2 基础知识点

### 2.1 并发三要素：可见性，原子性，有序性

* 可见性：一个线程对共享变量的修改，另一个线程能够立刻看到
* 原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行
* 有序性：即程序执行的顺序按照代码的先后顺序执行

### 2.2 Java是怎么解决并发问题的：JMM（Java内存模型）

Java 内存模型规范了 JVM 如何提供按需禁用缓存和编译优化的方法。具体来说，这些方法包括：

- volatile、synchronized 和 final 三个关键字
- Happens-Before 规则

如何保证并发三要素

* 保证原子性：

  通过synchronized和Lock来实现，保证任一时刻只有一个线程执行该代码块

* 保证可见性：

  1. Java提供了volatile关键字来保证可见性。当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。
  2. 另外，通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。

* 保证有序性：

  在Java里面，可以通过volatile关键字来保证一定的“有序性”。另外可以通过synchronized和Lock来保证有序性

### 2.3 线程安全

可以将共享数据按照安全程度的强弱顺序分成以下五类: 不可变、绝对线程安全、相对线程安全、线程兼容和线程对立。

#### 2.3.1 互斥同步

synchronized 和 ReentrantLock。

#### 2.3.2 非阻塞同步

* ABA问题

如果一个变量初次读取的时候是 A 值，它的值被改成了 B，后来又被改回为 A，那 CAS 操作就会误认为它从来没有被改变过。比如下面的例子：

假设有两个线程 T1 和 T2 都要使用 CAS 操作修改共享变量 X 的值，它们执行的顺序如下：

1. 线程 T1 读取 X 的值为 A。
2. 线程 T2 读取 X 的值为 A。
3. 线程 T2 将 X 的值修改为 B。
4. 线程 T2 又将 X 的值修改回 A。
5. 线程 T1 将 X 的值修改为 C。

此时，X 的最终值为 C，但实际上它已经被修改过了两次。换句话说，线程 T1 并没有注意到中间发生的 A->B->A 的变化，因此可能会造成意想不到的后果。这就是多线程的ABA问题。为了解决它，需要使用类似于版本号或时间戳的方法来确保数据在修改时的唯一性。

J.U.C 包提供了一个带有标记的原子引用类 AtomicStampedReference 来解决这个问题，它可以通过控制变量值的版本来保证 CAS 的正确性。如果需要解决 ABA 问题，改用传统的互斥同步可能会比原子类更高效

#### 2.3.3 无同步方案

* 线程本地存储（Thread Local Storage）

如果能保证共享数据的代码在同一个线程中执行，我们就可以把共享数据的可见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题。

可以使用 java.lang.ThreadLocal 类来实现线程本地存储功能。

> ThreadLocal 是一种 Java 提供的线程封闭技术，它可以使得一个变量在每个线程中都有独立的副本，从而实现了线程间数据隔离。
>
> ThreadLocal 的主要作用是解决多线程并发访问共享变量时出现的线程安全问题。在多线程环境下，如果多个线程同时访问同一个共享变量，就可能会出现竞态条件（Race Condition）和数据不一致等问题。
>
> 通过使用 ThreadLocal 可以将共享变量转化为线程私有的变量，每个线程只能访问自己的变量副本，从而避免了多线程之间的干扰和竞争。这样，即使多个线程同时访问同一个 ThreadLocal 变量，它们也不会相互影响，从而保证了并发程序的正确性和稳定性。
>
> 在实际开发中，ThreadLocal 主要应用于需要保存线程上下文信息、跨多个组件或框架的操作上下文、缓存、连接池等方面。比如，在 Web 开发中，一个请求对应一个线程，可以利用 ThreadLocal 存储当前请求的用户信息、语言环境等上下文信息，以便后续代码处理请求时可以方便地获取这些信息。

## 3 Java并发工具类

